= CIP2016-06-22 - Nested subqueries
:numbered:
:toc:
:toc-placement: macro
:source-highlighter: codemirror

*Authors:* Petra Selmer <petra.selmer@neotechnology.com>, Stefan Plantikow <stefan.plantikow@neotechnology.com>

[abstract]
.Abstract
--
This CIP proposes the incorporation of nested subqueries into Cypher.
--

toc::[]


== Motivation

Subqueries - i.e. queries within queries - are a powerful and expressive feature allowing for:

  * Increased query expressivity
  * Better query construction and readability
  * Easier query composition and reuse
  * Post-processing as a single unit results from multiple queries
  * Perform a sequence of multiple write commands for each record

== Background

This CIP may be viewed in conjunction with the EXISTS CIP and the Pattern Comprehension CIP, both of which propose variants of subqueries.


== Proposal

This proposal suggests the introduction of two new subquery constructs to Cypher.

**1. Read-only subqueries**

We propose the addition of new syntax to the `MATCH` clause for expressing nested read-only subqueries.

Nested subqueries are self-contained, read-only Cypher queries.

A nested read-only subquery is denoted using the following syntax: `MATCH { <subquery> }`.

Nested subqueries may be correlated - i.e. the subquery has a dependency on the outer query - or uncorrelated.

As this proposal extends the `MATCH` clause, nested subqueries can be contained within other nested subqueries at arbitrary depth.

**2. Write-only/read-write subqueries**

We further propose the addition of a new syntax - the `DO` clause - for expressing nested write-only/read-write subqueries that _do not return any data_.

A nested write-only/read-write subquery is denoted using the following syntax: `DO { <subquery> }`.

We additionally propose removing the `FOREACH` clause from the current language as it is rendered obsolete by the introduction of `DO`.


=== Syntax

We extend the https://github.com/opencypher/openCypher/blob/master/grammar/cypher.xml[grammar] as follows:

**1. Read-only subqueries**

[source, ebnf]
----
Match = [ "OPTIONAL" ], ( MatchPattern | NestedReadOnlySubquery ), [ "WHERE", Predicate ] ;
MatchPattern = "MATCH", Pattern ;
NestedReadOnlySubquery = "MATCH", "{", RegularQuery, "}" ;
----

**2. Write-only/read-write subqueries**

[source, ebnf]
----
Match = [ "OPTIONAL" ], "MATCH", Pattern, [ "WHERE", Predicate ], NestedWriteSubquery ;
NestedWriteSubquery = Unwind, "DO", "{", WriteSubquery, "}" ;
WriteSubquery = WriteOnlyClauseWithNoReturn, [ NestedWriteSubquery ] |
                ReadWriteClauseWithNoReturn, [ NestedWriteSubquery ] ;
----

=== Semantic clarification

**1. Read-only subqueries**

Conceptually, a nested subquery is evaluated for each incoming record and may produce an arbitrary number of result records.

All incoming variables remain in scope.

Any new variable bindings introduced by the final `RETURN` clause when evaluating the subquery will augment the variable bindings of the initial record. Therefore, nested subqueries cannot shadow variables present in the outer scope, and thus behave in the same way as `UNWIND` and `CALL` with regard to the introduction of new variable bindings.

Subqueries interact with write clauses in the same way as `MATCH` does.

It is an error for a nested subquery to try to rebind (shadow) a pre-existing outer variable binding.

**2. Write-only/read-write subqueries**

Execution of a `DO` subquery does not change the cardinality; i.e. the full subquery is run for each incoming record and then the record is being passed on to the remainder of the outer query. This is identical to way in which void procedures are executed.

=== Examples

**1. Read-only subqueries**

Post-UNION processing:
[source, cypher]
----
MATCH {
  // authored tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:AUTHORED]-(tweet:Tweet)
  RETURN tweet, tweet.time AS time, user.country AS country
  UNION
  // favorited tweets
  MATCH (me:User {name: 'Alice'})-[:FOLLOWS]->(user:User),
        (user)<-[:HAS_FAVOURITE]-(favorite:Favorite)-[:TARGETS]->(tweet:Tweet)
  RETURN tweet, favourite.time AS time, user.country AS country
}
WHERE country = 'se'
RETURN DISTINCT tweet
ORDER BY time DESC
LIMIT 10
----

Uncorrelated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})-[:IS_IN]->(country:Country)
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b.name AS name, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b.name AS name, p.code AS code
}
RETURN f, name, code
----

Filtered and correlated nested subquery:
[source, cypher]
----
MATCH (f:Farm)-[:IS_IN]->(country:Country)
WHERE country.name IN $countryNames
MATCH {
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(p:Lawnmower)
  RETURN b AS brand, p.code AS code
  UNION
  MATCH (u:User {id: $userId})-[:LIKES]->(b:Brand),
        (b)-[:PRODUCES]->(v:Vehicle),
        (v)<-[:IS_A]-(:Category {name: 'Tractor'})
  WHERE v.leftHandDrive = country.leftHandDrive
  RETURN b AS brand, p.code AS code
}
WHERE f.type = 'organic'
  AND b.certified
RETURN f, brand.name AS name, code
----

Doubly-nested subquery:
[source, cypher]
----
MATCH (f:Farm {id: $farmId})
MATCH {
  MATCH (c:Customer)-[:BUYS_FOOD_AT]->(f)
  MATCH {
     MATCH (c)-[:RETWEETS]->(t:Tweet)<-[:TWEETED_BY]-(f)
     RETURN c, count(*) AS count
     UNION
     MATCH (c)-[:LIKES]->(p:Posting)<-[:POSTED_BY]-(f)
     RETURN c, count(*) AS count
  }
  RETURN c, 'customer' AS type, sum(count) AS endorsement
  UNION
  MATCH (s:Shop)-[:BUYS_FOOD_AT]->(f)
  MATCH (s)-[:PLACES]->(a:Advertisement)-[:ABOUT]->(f)
  RETURN s, 'shop' AS type, count(a) * 100 AS endorsement
}
RETURN f.name AS name, type, sum(endorsement) AS endorsement
----

**2. Write-only/read-write subqueries**

We illustrate these by means of an 'old' version of the query, in which `FOREACH` is used, followed by the 'new' version, using `DO`.

Using a single subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH(x IN range(1, 10) |
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
)
----

Using a single subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x
DO {
  MERGE (c:Child {id: x})
  MERGE (r)-[:PARENT]->(c)
}
----

Doubly-nested subquery - old version using `FOREACH`:
[source, cypher]
----
MATCH (r:Root)
FOREACH (x IN range(1, 10) |
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  FOREACH (y IN range(1, 10) |
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  )
)
----

Doubly-nested subquery - new version using `DO`:
[source, cypher]
----
MATCH (r:Root)
UNWIND range(1, 10) AS x AS x
DO {
  CREATE (r)-[:PARENT]->(c:Child {id: x})
  MERGE (r)-[:PUBLISHES]->(t:Topic {id: r.id + x})
  UNWIND range(1, 10) AS y
  DO {
    CREATE (c)-[p:PARENT]->(:Child {id: c.id * 10 + y})
    SET p.id = c.id * 5 + y
  }
}
----

=== Interaction with existing features

Apart from the suggested deprecation of the `FOREACH` clause, nested read-only, write-only and read-write subqueries do not interact directly with any existing features.

=== Alternatives

Alternative syntax has been considered during the production of this document:

  * Using round braces; i.e. `MATCH (...)`
  * Using alternative keywords:

    ** `SUBQUERY`
    ** `QUERY`

== What others do

=== SQL

The following types of subqueries are supported in SQL:

Scalar:
[source, cypher]
----
SELECT orderID
FROM Orders
WHERE orderID =
  (SELECT max(orderID) FROM Orders)
----

Multi-valued:
[source, cypher]
----
SELECT customerID
FROM Customers
WHERE customerID IN
  (SELECT customerID FROM Orders)
----

Correlated:
[source, cypher]
----
SELECT orderID, customerID
FROM Orders AS O1
WHERE orderID =
  (SELECT max(O2.orderID) FROM Orders AS O2
   WHERE O2.customerID = O1.customerID)
----

Table-valued/table expression:
[source, cypher]
----
SELECT orderYear
FROM
  (SELECT YEAR(orderDate) AS orderYear
  FROM Orders) AS D
----

Both scalar and table expression subqueries are out of scope for the purposes of this CIP. They will be addressed in forthcoming CIPs.

=== SPARQL

https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#subqueries[SPARQL] only supports uncorrelated subqueries, exemplified by:

[source, cypher]
----
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
 {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}
----

Owing to the bottom-up nature of SPARQL query evaluation, the subqueries are evaluated logically first, and the results are projected up to the outer query.

Only variables projected out of the subquery will be visible, or in scope, to the outer query.


== Benefits to this proposal

* Increasing the expressivity of the language.
* Allowing unified post-processing on results from multiple (sub)queries; this is exemplified by the https://github.com/neo4j/neo4j/issues/2725[request for post-UNION processing].
* Facilitating query readability, construction and maintainability.
* Providing a feature familiar to users of SQL.

== Caveats to this proposal

At the current time, we are not aware of any caveats.
